# 01. Call Stack (호출 스택)

- 호출 스택이란?
    
    함수의 호출을 스택 방식으로 기록하는 구조.
    
    1. JavaScript 호출 스택은 자스 함수를 호출하는 매커니즘 / 코드가 실행되면서 Stack Frame이 쌓이는 장소 / 함수 실행 호출이 쌓이는 곳이다.
    
    

자바 스크립트는 **단 하나의 호출 스택**을 사용 → single threaded 랭귀지. 어느 한 함수가 실행되면 이 함수의 실행이 끝날 떄 까지 다른 작업을 수행할 수 없다.

JavaScript는 요청(Request)이 들어올 떄 마다 순차적으로 호출 스택에 담아 처리.

메서드가 실행될 떄 Call Stack에 새로운 프레임을 만들고 그곳에 push한다. 반대로 메서드의 실행이 끝나면 해당 프레임은 pop이 됨

브라우저에서 호출 스택에 실행할 함수가 쌓여있는 동안은 다른 일을 할 수 없다. 이 상태를 `blocked`라 한다. 이 상태에서 브라우저는 렌더링도 할 수 없고, 다른 코드를 실행할 수도 없다.

- 브라우저 자체가 동작을 하지 않음.
- 매끄러운 화면 UI를 제공하지 못하게 됨
- 프로그램 동작 중에 이러한 현상은 사용자 경험을 완전히 망가뜨리는 일

우리는 빈 호출 스택으로 시작하며, 함수를 호출할 때마다 자동으로 호출 스택에 추가되고, 해당 코드가 모두 실행된 후, 호출 스택에서 자동으로 제거됩니다. 결국, 마찬가지로 빈 호출 스택으로 끝납니다.

자바스크립트는 단일 스레드 프로그래밍 언어이므로, 단일 호출 스택이 있습니다. 단일 호출 스택이 있다는 뜻은 한 번에 하나의 일(Task)만 처리할 수 있다는 뜻입니다.

- Stack Frame
        
        함수가 호출될 때, 그 함수만의 스택 영역을 구분하기 위해 생성되는 공간.
        
        이 공간에는 함수와 관계되는 지역 번수, 매개변수가 저장되며, 함수 호출 시 할당되며, 함수가 종료되면서 소멸
        
        **함수 프롤로그(Prolog)**와 **함수 에필로그(Epilog)**라는 것을 수행

- 단점
    
    브라우저에서 호출 스택에 실행할 함수가 쌓여있는 동안은 다른 일을 할 수 없다. 이 상태를 `blocked`라 한다. 이 상태에서 브라우저는 렌더링도 할 수 없고, 다른 코드를 실행할 수도 없다.
    
    - 브라우저 자체가 동작을 하지 않음.
    - 매끄러운 화면 UI를 제공하지 못하게 됨
    - 프로그램 동작 중에 이러한 현상은 사용자 경험을 완전히 망가뜨리는 일

우리는 빈 호출 스택으로 시작하며, 함수를 호출할 때마다 자동으로 호출 스택에 추가되고, 해당 코드가 모두 실행된 후, 호출 스택에서 자동으로 제거됩니다. 결국, 마찬가지로 빈 호출 스택으로 끝납니다.

[https://0e.medium.com/도대체-promise가-뭔데-b0940365610d](https://0e.medium.com/%E1%84%83%E1%85%A9%E1%84%83%E1%85%A2%E1%84%8E%E1%85%A6-promise%E1%84%80%E1%85%A1-%E1%84%86%E1%85%AF%E1%86%AB%E1%84%83%E1%85%A6-b0940365610d)

→ gif로 설명이 잘되어잇음

### 자바스크립트 엔진

---

JavaScript로 작성한 코드를 해석하고 실행하는 인터프리터.  ex)크롬, Node.js에서 사용하는 V8

### Call Stack

Call Stack은 코드가 실행되면서 스택 프레임이 쌓이는 장소 / 함수 실행 호출이 쌓이는 곳

자바 스크립트는 **단 하나의 호출 스택**을 사용 → single threaded 랭귀지. 어느 한 함수가 실행되면 이 함수의 실행이 끝날 떄 까지 다른 작업을 수행할 수 없다.

자바스크립트 엔진은 어떤 요청이 들어올 떄마다 해당 요청을 순차적으로 Call Stact에 담아 처리한다. 

메서드가 실행될 떄 Call Stack에 새로운 프레임을 만들고 그곳에 push한다. 반대로 메서드의 실행이 끝나면 해당 프레임은 pop이 됨

### Heap

---

보통 구조화 되지 않은 더미메모리 영역

변수와 객체에 대한 모든 메모리 할당

JS의 경우 동적으로 생성된 객체들이 이곳에 할당

### Queue(Task Queue or Event Queue)

---

JavaScript의 런타임 환경에서는 처리해야하는 Task들을 임시로 저장하는 대기 Queue가 존재

이 Task Queue에 들어있는 Task들은 Call Stack이 empty일때, 대기열에 들어온 순서대로 수행

setTimeout과 같은 비동기로 호출되는 함수들은 Call Stack에 쌓이는 것이 아니라 Task Queue로 enqueue된다.   event loop가 감시하다가 콜스택이 비면 콜백함수를 call stack으로 보냄

Web API (브라우저에서 동작하게끔 만들어진 API) ex) console, setTimeout, fetch, onclick ajax 요청, 이벤트 리스너나 FileReader 등 (노드에서도 쓸수잇는데?→ 노드에서 구현해 둔 것 뿐

싱글스레드인 JS가 비동기 처리가 가능한 이유는 Web API를 통해 브라우저나 NodeJS가 처리하기 때문이다.

심지어 태스크 큐 외에도 마이크로태스크 큐, 잡 큐 등이 더 있어 이벤트 루프가 실행하는 순서가 다릅니다.

### 이벤트루프

---

하나의 단순한 동작만을 수행.

Call Stack이 비어있는지 아닌지, Task Queue에 Task가 존재하는지 아닌지 판단하는 역할을 맡습니다.

Call Stack과 Task Queue를 감시하면서, 만약 Call Stack이 비어있다면 이벤트 루프는 큐에서 첫 번째 Task를 호출스택에 넣고 Task가 수행됨.

**컴파일러(Compiler) 방식**은 고급 언어로 작성된 프로그램 전체를 한 번에 기계어로 번역한 후 링킹 작업을 거쳐 컴퓨터에서 실행 가능한 실행 프로그램을 만듭니다. 

**인터프리터(Interpreter) 방식**은 고급언어로 작성된 프로그램을 한 줄씩 기계어로 번역한 후 즉시 실행하는 방식입니다.

### JavaScript동작원리

---

Web API는 브라우저에서 제공되는 API이며, AJax나 Timeout같은 비동기 작업을 실행합니다. 자바스크립트에서 setTimeout함수를 실행하면, 자바스크립트 엔진은 Web API에 setTimeout을 요청합니다.
CallStack에서는 Web API 요청 이후, setTimeout 함수가 종료되기 때문에 제거됩니다(pop). 그래서 Web API는 방금 요청받은 setTimeout을 완료하고, 전달받은 Callback을 Task Queue에 넘겨줍니다.
Task Queue는 Callback Queue라고도 하는데, Web API에서 넘겨받은 Callback 함수를 저장하는 Queue입니다. 이 Callback 함수들은 Task Queue에 enqueue되어 있다가 자바스크립트 엔진의 CallStack이 비었을 때, Call Stack으로 push됩니다.
이때, Event Loop가 Call Stack이 비어있는지 아닌지, Task Queue에 Task가 존재하는지 아닌지 판단하는 역할을 맡습니다.

### 오버플로우

---

스택도 최대 공간이 있으며, 브라우저마다 스택의 크기가 다르다. 일반적으로 10,000 개 정도 있다고 한다. 재귀등 스택이 가득차면 오버플로우가 발생함.
정상적인 재귀라도 너무 많은 호출이 이뤄질 경우


### 자바스크립트 엔진

정의: 

자바스크립트 코드를 실행하는 인터프리터 또는 프로그램이라고 볼 수 있다.

전형적인 인터프리터의 역할 및 JIT(Just-In-Time) 컴파일 활용 및 많은 기능을 하고, 주로 웹 브라우저를 위해 사용된다.

인터프리터 언어에는 스크립트 언어가 대부분인데, JS나 HTML, python, Ruby 등이 있다.

정적 컴파일 언어에는 자료형이 고정되어 있는 언어 즉 JAVA나 C같은 언어들이다.

JIT(Just-In-Time)

동적 번역

프로그램을 실제 실행하는 시점에 바이트 코드를 기계어로 번역하는 컴파일 기법. 그때그때 

자바스크립트 엔진의 코드 해석 및 실행 프로세스의 목표는 가능한한 짧은 시간내에 가장 최적화된 코드를 생성하는 것

자바스크립트 엔진의 기본적인 역할은, 개발자가 작성한 자바스크립트 코드를 브라우저에 의해 해석되거나 어플리케이션에 임베드 될 수 있는 빠르고 최적화된 코드로 변환하는 일

대표적으로:

- 크롬, 노드는 v8엔진(C++로 만들어짐)이다 ,
- 참고로 ie, edge는 Chakra, firefox는 spiderMonkey(최초javascript engine), JavaScriptCore or 니트로 는 사파리

구성요소 : 

- **Memory Heap** : 메모리 할당이 일어나는 곳
- **Call Stack** : 코드 실행에 따라 호출 스택이 쌓이는 곳

자바스크립트 엔진(힙, 콜스택) 이외에도 Web API(DOM, Ajax, setTimeout 등), 이벤트 루프, 콜백 큐 가 있다.

참고로 백그라운드에서 3초를 정확하게 세어 주었다고 하더라도, 호출 스택에 함수들이 가득차 있다면 3초 후에 실행되지 않을 수도 있습니다.
이벤트 루프가 태스크 큐에서 run 함수를 호출 스택으로 끌어올리지 못하거든요. setTimeout의 초가 정확하지 않을 수도 있는 이유입니다.
호출 스택에서 너무 많은 일을 하게 되면 태스크 큐에 쌓인 콜백 함수들이 제 때에 실행되지 않기 때문에 너무 버거운 일들은 하지 않는 게 좋습니다.

